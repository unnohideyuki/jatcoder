/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package jp.ne.sakura.uhideyuki.jatcoder;

import static org.junit.jupiter.api.Assertions.*;

import org.junit.jupiter.api.Test;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.ArrayList;

class SegtreeTest {
    @Test
    void segtree_set_get() {
        final int n = 100;
        final BiFunction<Integer, Integer, Integer> op = (a, b) -> { return a + b; };
        final Integer e = 0;
        final Segtree<Integer> seg = new Segtree<>(op, e, n);
        for (int i = 0; i < n; i++) {
            seg.set(i, i);
        }
        for (int i = 0; i < n; i++) {
            assertEquals(i, seg.get(i));
        }
    }

    @Test
    void segtree__set_prod() {
        final int n = 100;
        final BiFunction<Integer, Integer, Integer> op = (a, b) -> { return a + b; };
        final Integer e = 0;
        final Segtree<Integer> seg = new Segtree<>(op, e, n);
        final ArrayList<Integer> arr = new ArrayList<>(n);
        for (int i = 0; i < n; i++){
            arr.add(i);
            seg.set(i, i);
        }

        for (int l = 0; l < n; l++){
            for (int r = l; r <= n; r++){
                int sum = 0;
                for (int i = l; i < r; i++) {
                    sum += arr.get(i);
                }
                assertEquals(sum, seg.prod(l, r));
                if ((l == 0) && (r == n)) {
                    assertEquals(sum, seg.allProd());
                }
            }
        }
    }

    @Test
    void segtree__list_prod() {
        final int n = 100;
        final BiFunction<Integer, Integer, Integer> op = (a, b) -> { return a + b; };
        final Integer e = 0;
        final ArrayList<Integer> arr = new ArrayList<>(n);
        for (int i = 0; i < n; i++){
            arr.add(i);
        }
        final Segtree<Integer> seg = new Segtree<>(op, e, arr);

        for (int l = 0; l < n; l++){
            for (int r = l; r <= n; r++){
                int sum = 0;
                for (int i = l; i < r; i++) {
                    sum += arr.get(i);
                }
                assertEquals(sum, seg.prod(l, r));
                if ((l == 0) && (r == n)) {
                    assertEquals(sum, seg.allProd());
                }
            }
        }
    }

    @Test
    void segtree_maxRight() {
        final int n = 100;
        final BiFunction<Integer, Integer, Integer> op = (a, b) -> { return a + b; };
        final Integer e = 0;
        final Segtree<Integer> seg = new Segtree<>(op, e, n);
        final ArrayList<Integer> arr = new ArrayList<>(n);
        for (int i = 0; i < n; i++) {
            seg.set(i, 1);
            arr.add(1);
        }
        final int w = 19;
        final Function<Integer, Boolean> f = (s) -> { return s <= w; };
        for (int l = 0; l <= n; l++){
            final int r = seg.maxRight(l, f);
            if (l + w <= n) {
                assertEquals(w, r - l);
            } else {
                assertEquals(n, r);
            }
        }
    }

    @Test
    void segtree_minLeft() {
        final int n = 100;
        final BiFunction<Integer, Integer, Integer> op = (a, b) -> { return a + b; };
        final Integer e = 0;
        final Segtree<Integer> seg = new Segtree<>(op, e, n);
        final ArrayList<Integer> arr = new ArrayList<>(n);
        for (int i = 0; i < n; i++) {
            seg.set(i, 1);
            arr.add(1);
        }
        final int w = 19;
        final Function<Integer, Boolean> f = (s) -> { return s <= w; };
        for (int r = 0; r <= n; r++){
            final int l = seg.minLeft(r, f);
            if (r - w >= 0) {
                assertEquals(w, r - l);
            } else {
                assertEquals(0, l);
            }
        }
    }
}
